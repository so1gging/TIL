# 2026.02.26

## CloudFront Invalidation 이슈 해결기

### 문제 상황

#### 프로젝트 구조
- **프레임워크**: Next.js
- **배포 환경**: S3 + CloudFront
- **배포 도구**: gulp
- **배포 전략**: 변경된 파일만 invalidation

#### 발생한 문제
1. 신규 기능을 배포했는데 일부 사용자에게 기능이 동작하지 않음
2. 오래전에 방문했던 사용자가 해당 경로 재방문 시 **예전 JavaScript 번들**이 로드됨
3. 새로운 기능에 접근할 수 없는 버그 발생

---

## 원인 분석

### CloudFront 캐싱 구조

```
사용자 브라우저
    ↓
CloudFront (CDN)
    ├─ /index.html (캐시됨)
    ├─ /_next/static/chunks/main-abc123.js (오래된 캐시) ❌
    └─ /_next/static/chunks/pages/home-xyz789.js (새로운 파일) ✅
    ↓
S3 버킷 (실제 파일)
```

### 문제의 핵심

```
배포 1차 (1주일 전):
  - /page/feature.html → invalidation ✅
  - /_next/static/chunks/main-abc123.js → 캐시됨 (24시간 TTL)

배포 2차 (오늘):
  - /page/feature.html → invalidation ✅ (변경됨)
  - /_next/static/chunks/main-def456.js → 새 파일 업로드
  - 문제: main-abc123.js는 invalidation 안 함 ❌
  
사용자 접속:
  - feature.html → 새 버전 로드 ✅
  - 근데 HTML이 main-abc123.js 참조 → 오래된 번들 로드 ❌
  - 신규 기능 동작 안 함! 💥
```

### 왜 이런 일이?

**Next.js 빌드 특성:**
- HTML 파일은 경로가 같음 (`/page/feature.html`)
- JavaScript 번들은 **해시가 포함된 파일명** (`main-abc123.js`)
- HTML이 참조하는 JS 파일명이 바뀌는데, **변경된 파일만 invalidation**하면 일부 경로가 누락됨

**CloudFront 동작:**
- Invalidation 안 된 파일은 **TTL 만료까지 오래된 캐시** 제공
- 사용자가 오래전에 방문했다면 **구 버전 파일들이 브라우저 캐시**에 남아있음

---

## 해결 방법

### 1️⃣ 임시 해결: 전체 경로 무효화 (적용한 방법)

```javascript
// gulp 배포 스크립트 수정 전
gulp.task('invalidate', () => {
  return cloudfront.invalidate({
    paths: changedFiles, // 변경된 파일만
  });
});

// ✅ 수정 후
gulp.task('invalidate', () => {
  return cloudfront.invalidate({
    paths: ['/*'], // 전체 무효화
  });
});
```

**장점:**
- 확실하게 모든 캐시 제거
- 문제 즉시 해결

**단점:**
- CloudFront invalidation 비용 증가 (1,000개 경로까지 무료, 이후 과금)
- CDN 캐시 이점 상실

---

### 2️⃣ 근본 해결책들

#### A. Next.js 빌드 해시 기반 캐싱 전략

```nginx
# CloudFront 캐시 설정 최적화

# HTML 파일: 짧은 캐시 (또는 no-cache)
/page/*.html
  Cache-Control: public, max-age=0, must-revalidate
  → HTML은 항상 최신 버전

# JS/CSS (해시 포함): 긴 캐시
/_next/static/*
  Cache-Control: public, max-age=31536000, immutable
  → 파일명이 바뀌니까 영구 캐시 OK
```

**원리:**
- HTML은 항상 최신 버전 로드 → 새로운 JS 번들 파일명 참조
- JS 번들은 파일명이 바뀌면 자동으로 새 파일 다운로드
- **Invalidation 불필요!**

#### B. 패턴 기반 Invalidation

```javascript
// 변경된 HTML 페이지와 관련 청크 모두 무효화
gulp.task('invalidate', () => {
  const paths = [
    '/page/*',           // 모든 HTML
    '/_next/static/*',   // 모든 정적 파일
    '/_next/data/*',     // Next.js 데이터
  ];
  
  return cloudfront.invalidate({ paths });
});
```

#### C. 빌드 ID 기반 경로 변경

```javascript
// next.config.js
module.exports = {
  assetPrefix: process.env.CDN_URL,
  generateBuildId: async () => {
    return Date.now().toString(); // 또는 git commit hash
  },
};
```

---

## 학습 포인트

### 1. CloudFront Invalidation 비용
- **처음 1,000개 경로**: 무료
- **그 이상**: 경로당 $0.005
- `/*` (전체 무효화) = 1개 경로로 카운트 ✅

### 2. Next.js 정적 자산 특성
- `/_next/static/` 내 파일은 **빌드 해시 포함**
- 파일명이 바뀌므로 **긴 캐시 TTL 설정해도 안전**
- HTML은 **파일명 안 바뀜** → 짧은 캐시 필요

### 3. 캐싱 전략 베스트 프랙티스

```
콘텐츠 타입별 캐시 전략:

📄 HTML
  - CloudFront: 짧게 (1시간 이하) 또는 no-cache
  - 이유: 항상 최신 번들 참조해야 함

🎨 JS/CSS (해시 포함)
  - CloudFront: 1년 (immutable)
  - 이유: 파일명 바뀌면 자동으로 새 파일

🖼️ 이미지 (해시 없음)
  - CloudFront: 1일~1주
  - 이유: 변경 빈도 낮음

🔄 API 응답
  - CloudFront: 캐시 안 함 또는 매우 짧게
  - 이유: 동적 데이터
```

---

## 해결 과정 요약

### 문제 흐름
```
배포 → 변경된 파일만 invalidation 
→ 오래된 JS 번들이 CloudFront에 남음
→ 사용자가 캐시된 HTML 접근 → 예전 번들 참조
→ 신규 기능 동작 안 함 ❌
```

### 해결 흐름
```
배포 → 전체 경로 무효화 (/*) 
→ 모든 캐시 제거
→ 사용자가 접근 → 최신 HTML + 최신 번들
→ 신규 기능 정상 동작 ✅
```

---

## 향후 개선 방안

### 1️⃣ 단기: 패턴 기반 Invalidation
```javascript
// 매번 이 패턴들은 무조건 무효화
const paths = [
  '/page/*',
  '/_next/static/chunks/*',
  '/_next/data/*',
];
```

### 2️⃣ 장기: Cache-Control 헤더 최적화
```javascript
// S3 업로드 시 파일 타입별 헤더 설정
if (file.endsWith('.html')) {
  CacheControl: 'public, max-age=0, must-revalidate'
} else if (file.includes('/_next/static/')) {
  CacheControl: 'public, max-age=31536000, immutable'
}
```

→ 이렇게 하면 **invalidation 자체가 거의 불필요**해짐!

---

## 교훈

1. **변경된 파일만 invalidation → 위험할 수 있음**
   - Next.js처럼 파일 간 의존성이 있는 경우 문제 발생 가능
   
2. **전체 invalidation (`/*`)** 
   - 비용은 동일 (1개 경로)
   - 확실한 해결책
   - 단, CDN 캐시 효율 떨어짐

3. **근본 해결은 Cache-Control 전략**
   - HTML: 짧은 캐시
   - JS/CSS (해시 포함): 긴 캐시
   - Invalidation 최소화

4. **해시 기반 파일명의 중요성**
   - Next.js는 이미 지원
   - 파일명만 바뀌면 캐시 문제 없음
   - HTML이 항상 최신이면 자동으로 새 번들 참조

---

## 참고: CloudFront Invalidation API

```bash
# AWS CLI로 invalidation 실행
aws cloudfront create-invalidation \
  --distribution-id E1234567890ABC \
  --paths "/*"

# 특정 경로만
aws cloudfront create-invalidation \
  --distribution-id E1234567890ABC \
  --paths "/page/*" "/_next/static/*"
```
