### 보호구문
- 하나의 루틴에는 하나의 반환문
- 하지만 남용은 하지 말자
- early return 사용

**전**
  ```py
          if queue_name not in self.queues:
            self.emit_before("declare_queue", queue_name)
            self.queues[queue_name] = Queue()
            self.emit_after("declare_queue", queue_name)

            delayed_name = dq_name(queue_name)
            self.queues[delayed_name] = Queue()
            self.delay_queues.add(delayed_name)
            self.emit_after("declare_delay_queue", delayed_name)
  ```
**후**
```py
        if queue_name in self.queues:
            return

        self.emit_before("declare_queue", queue_name)
        self.queues[queue_name] = Queue()
        self.emit_after("declare_queue", queue_name)

        delayed_name = dq_name(queue_name)
        self.queues[delayed_name] = Queue()
        self.delay_queues.add(delayed_name)
        self.emit_after("declare_delay_queue", delayed_name)
```

---
### 안 쓰는 코드
- 지워버리자.

---
### 대칭으로 맞추기
- 코드를 작성하는 방식은 한 가지 방식을 선택하자
- 다른 방식으로 작성한 코드를 선택한 방식으로 고치자
- 비슷해보이지만 같지 않은 루틴을 찾아내 분리하자

---
### 새로운 인터페이스로 기존 루틴 부르기
- 루틴을 호출해야 하는데 기존 인터페이스 때문에 어려우면 새롭게 구현해서 호출하자
- 이렇게 새롭게 구현한 통로 인터페이스 중추적인 역할을 한다.

---
### 읽는 순서
- 읽기 좋은 순서로 정렬하자
---
### 응집도를 높이는 배치
- 코드를 읽다가 변경해야 할 동작을 찾았더니 여러 곳에 흩어져 있는 코드를 같이 바꿔야 한다는 것을 알게 된다면?
- 코드의 순서를 바꿔 변경할 요소들을 가까이 두자
- 응집도를 높이는 순서로 정리하면 코드를 더 쉽게 변경할 수 있음.
---
### 선언과 초기화를 함께 옮기기
- 초기화를 변수 선언 근처로 이동한다.
---
### 설명하는 변수
- 긴 표현식을 설명하는 변수를 할당하여 사용하자
---
### 설명하는 상수
- 상징적인 상수를 만들자. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꾼다.
---
### 명시적인 매개변수

**전**
```javascript
param = { a: 1, b: 2, c: 3, .... }
poo(param)

function poo(params)
	...params.a 코드... 
    ...params.b 코드...
```

**후**
```javascript
function poo(params)
   foo_body(params.a, params.b)

function foo_body(a, b)
... a, ...b
```

- 매개변수를 명시적으로 드러나게 만든 다음 함수를 연쇄적으로 호출할 수 있게 준비
---
### 비슷한 코드끼리
